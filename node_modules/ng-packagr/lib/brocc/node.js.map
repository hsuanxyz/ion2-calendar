{"version":3,"file":"node.js","sourceRoot":"","sources":["../../../src/lib/brocc/node.ts"],"names":[],"mappings":";;AAAA,IAAI,UAAU,GAAG,CAAC,CAAC;AAIN,QAAA,WAAW,GAAc,OAAO,CAAC;AACjC,QAAA,gBAAgB,GAAc,aAAa,CAAC;AAC5C,QAAA,aAAa,GAAc,SAAS,CAAC;AACrC,QAAA,UAAU,GAAc,MAAM,CAAC;AAE5C;;GAEG;AACH;IAGE,YAA4B,GAAW;QAAX,QAAG,GAAH,GAAG,CAAQ;QAQhC,UAAK,GAAc,EAAE,CAAC;QAcrB,gBAAW,GAAW,EAAE,CAAC;QACzB,eAAU,GAAW,EAAE,CAAC;QAtB9B,IAAI,CAAC,KAAK,GAAG,UAAU,EAAE,CAAC;IAC5B,CAAC;IAQM,MAAM,CAAC,EAA2C;QACvD,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;IACrC,CAAC;IAEM,IAAI,CAAC,EAA2C;QACrD,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IACnC,CAAC;IAED,IAAW,UAAU;QACnB,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC;IAC1B,CAAC;IAKD,2IAA2I;IACpI,SAAS,CAAC,SAAwB;QACvC,MAAM,OAAO,GAAG,SAAS,YAAY,KAAK,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC;QAErE,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;YACpB,GAAG,CAAC,UAAU,GAAG,GAAG,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACvE,CAAC,CAAC,CAAC;QAEH,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW;aAChC,MAAM,CAAC,QAAQ,CAAC,EAAE;YACjB,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,KAAK,QAAQ,CAAC,CAAC;QACrD,CAAC,CAAC;aACD,MAAM,CAAC,OAAO,CAAC,CAAC;IACrB,CAAC;CACF;AA1CD,oBA0CC","sourcesContent":["let NODE_COUNT = 0;\n\nexport type NodeState = '' | 'dirty' | 'in-progress' | 'pending' | 'done';\n\nexport const STATE_DIRTY: NodeState = 'dirty';\nexport const STATE_IN_PROGESS: NodeState = 'in-progress';\nexport const STATE_PENDING: NodeState = 'pending';\nexport const STATE_DONE: NodeState = 'done';\n\n/**\n * A Node in the {@link BuildGraph}.\n */\nexport class Node {\n  private readonly count: number;\n\n  constructor(public readonly url: string) {\n    this.count = NODE_COUNT++;\n  }\n\n  public type: string;\n\n  public data: any;\n\n  public state: NodeState = '';\n\n  public filter(by: (value: Node, index: number) => boolean): Node[] {\n    return this._dependents.filter(by);\n  }\n\n  public find(by: (value: Node, index: number) => boolean): Node | undefined {\n    return this._dependents.find(by);\n  }\n\n  public get dependents(): Node[] {\n    return this._dependents;\n  }\n\n  private _dependents: Node[] = [];\n  private _dependees: Node[] = [];\n\n  /** @experimental DO NOT USE. For time being, dirty checking is for `type=entryPoint && state !== 'done'` (full rebuild of entry point). */\n  public dependsOn(dependent: Node | Node[]) {\n    const newDeps = dependent instanceof Array ? dependent : [dependent];\n\n    newDeps.forEach(dep => {\n      dep._dependees = dep._dependees.filter(d => d !== this).concat(this);\n    });\n\n    this._dependents = this._dependents\n      .filter(existing => {\n        return newDeps.some(newDep => newDep !== existing);\n      })\n      .concat(newDeps);\n  }\n}\n"]}